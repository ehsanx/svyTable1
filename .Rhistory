paste(missing_vars, collapse = ", ")))
}
# --- Helper function for formatting ---
format_num <- function(n, is_weighted) {
if (is_weighted) n <- round(n)
if (commas) return(format(n, big.mark = ","))
return(as.character(n))
}
# --- Table Generation ---
if (nrow(df) == 0) return(data.frame(Error = "Input data has 0 rows"))
if(!is.factor(df[[strata_var]])) df[[strata_var]] <- factor(df[[strata_var]])
df[[strata_var]] <- droplevels(df[[strata_var]])
strata_levels <- levels(df[[strata_var]])
unweighted_n_overall <- nrow(df)
unweighted_n_strata <- table(df[[strata_var]])
header_row <- data.frame(Variable = "n", Level = "")
if (mode == "mixed") {
header_row$Overall <- format_num(unweighted_n_overall, FALSE)
for (lvl in strata_levels)
header_row[[lvl]] <- format_num(unweighted_n_strata[lvl], FALSE)
} else if (mode == "weighted") {
weighted_n_strata <- svytable(stats::as.formula(paste0("~", strata_var)), design)
header_row$Overall <- format_num(sum(stats::weights(design)), TRUE)
for (lvl in strata_levels)
header_row[[lvl]] <- format_num(weighted_n_strata[lvl], TRUE)
} else { # unweighted
header_row$Overall <- format_num(unweighted_n_overall, FALSE)
for (lvl in strata_levels)
header_row[[lvl]] <- format_num(unweighted_n_strata[lvl], FALSE)
}
results_list <- list(header_row)
for (var in table_vars) {
var_formula <- stats::as.formula(paste0("~", var))
strata_formula <- stats::as.formula(paste0("~", strata_var))
var_header_row <- as.data.frame(setNames(as.list(c(var, rep("", ncol(header_row) - 1))), names(header_row)))
results_list[[length(results_list) + 1]] <- var_header_row
if (is.factor(df[[var]])) {
df[[var]] <- droplevels(df[[var]])
unweighted_counts_overall <- table(df[[var]])
unweighted_pcts_overall <- stats::prop.table(unweighted_counts_overall) * 100
unweighted_counts_strata <- table(df[[var]], df[[strata_var]])
unweighted_pcts_strata <- stats::prop.table(unweighted_counts_strata, margin = 2) * 100
if (mode %in% c("weighted", "mixed")) {
weighted_counts_overall <- svytable(var_formula, design)
weighted_pcts_overall <- svymean(var_formula, design, na.rm = TRUE) * 100
weighted_counts_strata <- svytable(stats::as.formula(paste0("~", var, "+", strata_var)), design)
weighted_pcts_strata <- svyby(var_formula, strata_formula, design, svymean, na.rm = TRUE)
}
for (lvl in levels(df[[var]])) {
row_data <- data.frame(Variable = "", Level = lvl, stringsAsFactors = FALSE)
if (mode == "mixed") {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_overall[lvl], FALSE),
weighted_pcts_overall[paste0(var, lvl)])
} else if (mode == "weighted") {
val <- sprintf("%s (%.1f%%)", format_num(weighted_counts_overall[lvl], TRUE),
weighted_pcts_overall[paste0(var, lvl)])
} else {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_overall[lvl], FALSE),
unweighted_pcts_overall[lvl])
}
row_data$Overall <- val
for (s_lvl in strata_levels) {
if (mode == "mixed") {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_strata[lvl, s_lvl], FALSE),
weighted_pcts_strata[s_lvl, paste0(var, lvl)] * 100)
} else if (mode == "weighted") {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_strata[lvl, s_lvl], TRUE),
weighted_pcts_strata[s_lvl, paste0(var, lvl)] * 100)
} else {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_strata[lvl, s_lvl], FALSE),
unweighted_pcts_strata[lvl, s_lvl])
}
row_data[[s_lvl]] <- val
}
results_list[[length(results_list) + 1]] <- row_data
}
} else if (is.numeric(df[[var]])) {
unweighted_mean_overall <- mean(df[[var]], na.rm = TRUE)
unweighted_sd_overall <- stats::sd(df[[var]], na.rm = TRUE)
unweighted_mean_strata <- tapply(df[[var]], df[[strata_var]], mean, na.rm = TRUE)
unweighted_sd_strata <- tapply(df[[var]], df[[strata_var]], stats::sd, na.rm = TRUE)
if (mode %in% c("weighted", "mixed")) {
weighted_mean_overall <- svymean(var_formula, design, na.rm = TRUE)
weighted_var_overall <- svyvar(var_formula, design, na.rm = TRUE)
weighted_stats_strata <- svyby(var_formula, strata_formula, design, svymean, na.rm = TRUE)
weighted_var_strata <- svyby(var_formula, strata_formula, design, svyvar, na.rm = TRUE)
}
row_data <- data.frame(Variable = "", Level = "Mean (SD)", stringsAsFactors = FALSE)
if (mode %in% c("mixed", "weighted")) {
val <- sprintf("%.2f (%.2f)", weighted_mean_overall, sqrt(weighted_var_overall))
} else {
val <- sprintf("%.2f (%.2f)", unweighted_mean_overall, unweighted_sd_overall)
}
row_data$Overall <- val
for (i in seq_along(strata_levels)) {
s_lvl <- strata_levels[i]
if (mode %in% c("mixed", "weighted")) {
mean_val <- weighted_stats_strata[i, var]
sd_val <- sqrt(weighted_var_strata[i, var])
val <- sprintf("%.2f (%.2f)", mean_val, sd_val)
} else {
val <- sprintf("%.2f (%.2f)", unweighted_mean_strata[s_lvl], unweighted_sd_strata[s_lvl])
}
row_data[[s_lvl]] <- val
}
results_list[[length(results_list) + 1]] <- row_data
}
}
final_table <- do.call(rbind, results_list)
return(final_table)
}
# --- 3. Running Example: Flegal (2016) NHANES Data ---
# --- Data Preparation ---
# Load the dataset from a working URL.
load(url("https://raw.githubusercontent.com/epiverse-trace/datasets/raw/main/RData/Flegal2016.RData"))
load("E:/GitHub/EpiMethods/Data/surveydata/Flegal2016.RData")
# --- 1. Load Required Libraries ---
# This script requires the 'survey' and 'dplyr' packages.
# If you don't have them, run: install.packages(c("survey", "dplyr"))
library(survey)
library(dplyr)
# --- 2. The Final, Self-Contained svytable1 Function ---
# This function is robust and handles survey complexities internally.
svytable1 <- function(design, strata_var, table_vars,
mode = "mixed", commas = TRUE) {
# --- Lonely PSU Handling ---
old_option <- getOption("survey.lonely.psu")
options(survey.lonely.psu = "adjust")
on.exit(options(survey.lonely.psu = old_option))
# --- Input Validation ---
df <- design$variables
all_vars <- c(strata_var, table_vars)
missing_vars <- all_vars[!all_vars %in% names(df)]
if (length(missing_vars) > 0) {
stop(paste("The following variables were not found in the data:",
paste(missing_vars, collapse = ", ")))
}
# --- Helper function for formatting ---
format_num <- function(n, is_weighted) {
if (is_weighted) n <- round(n)
if (commas) return(format(n, big.mark = ","))
return(as.character(n))
}
# --- Table Generation ---
if (nrow(df) == 0) return(data.frame(Error = "Input data has 0 rows"))
if(!is.factor(df[[strata_var]])) df[[strata_var]] <- factor(df[[strata_var]])
df[[strata_var]] <- droplevels(df[[strata_var]])
strata_levels <- levels(df[[strata_var]])
unweighted_n_overall <- nrow(df)
unweighted_n_strata <- table(df[[strata_var]])
header_row <- data.frame(Variable = "n", Level = "")
if (mode == "mixed") {
header_row$Overall <- format_num(unweighted_n_overall, FALSE)
for (lvl in strata_levels)
header_row[[lvl]] <- format_num(unweighted_n_strata[lvl], FALSE)
} else if (mode == "weighted") {
weighted_n_strata <- svytable(stats::as.formula(paste0("~", strata_var)), design)
header_row$Overall <- format_num(sum(stats::weights(design)), TRUE)
for (lvl in strata_levels)
header_row[[lvl]] <- format_num(weighted_n_strata[lvl], TRUE)
} else { # unweighted
header_row$Overall <- format_num(unweighted_n_overall, FALSE)
for (lvl in strata_levels)
header_row[[lvl]] <- format_num(unweighted_n_strata[lvl], FALSE)
}
results_list <- list(header_row)
for (var in table_vars) {
var_formula <- stats::as.formula(paste0("~", var))
strata_formula <- stats::as.formula(paste0("~", strata_var))
var_header_row <- as.data.frame(setNames(as.list(c(var, rep("", ncol(header_row) - 1))), names(header_row)))
results_list[[length(results_list) + 1]] <- var_header_row
if (is.factor(df[[var]])) {
df[[var]] <- droplevels(df[[var]])
unweighted_counts_overall <- table(df[[var]])
unweighted_pcts_overall <- stats::prop.table(unweighted_counts_overall) * 100
unweighted_counts_strata <- table(df[[var]], df[[strata_var]])
unweighted_pcts_strata <- stats::prop.table(unweighted_counts_strata, margin = 2) * 100
if (mode %in% c("weighted", "mixed")) {
weighted_counts_overall <- svytable(var_formula, design)
weighted_pcts_overall <- svymean(var_formula, design, na.rm = TRUE) * 100
weighted_counts_strata <- svytable(stats::as.formula(paste0("~", var, "+", strata_var)), design)
weighted_pcts_strata <- svyby(var_formula, strata_formula, design, svymean, na.rm = TRUE)
}
for (lvl in levels(df[[var]])) {
row_data <- data.frame(Variable = "", Level = lvl, stringsAsFactors = FALSE)
if (mode == "mixed") {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_overall[lvl], FALSE),
weighted_pcts_overall[paste0(var, lvl)])
} else if (mode == "weighted") {
val <- sprintf("%s (%.1f%%)", format_num(weighted_counts_overall[lvl], TRUE),
weighted_pcts_overall[paste0(var, lvl)])
} else {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_overall[lvl], FALSE),
unweighted_pcts_overall[lvl])
}
row_data$Overall <- val
for (s_lvl in strata_levels) {
if (mode == "mixed") {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_strata[lvl, s_lvl], FALSE),
weighted_pcts_strata[s_lvl, paste0(var, lvl)] * 100)
} else if (mode == "weighted") {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_strata[lvl, s_lvl], TRUE),
weighted_pcts_strata[s_lvl, paste0(var, lvl)] * 100)
} else {
val <- sprintf("%s (%.1f%%)", format_num(unweighted_counts_strata[lvl, s_lvl], FALSE),
unweighted_pcts_strata[lvl, s_lvl])
}
row_data[[s_lvl]] <- val
}
results_list[[length(results_list) + 1]] <- row_data
}
} else if (is.numeric(df[[var]])) {
unweighted_mean_overall <- mean(df[[var]], na.rm = TRUE)
unweighted_sd_overall <- stats::sd(df[[var]], na.rm = TRUE)
unweighted_mean_strata <- tapply(df[[var]], df[[strata_var]], mean, na.rm = TRUE)
unweighted_sd_strata <- tapply(df[[var]], df[[strata_var]], stats::sd, na.rm = TRUE)
if (mode %in% c("weighted", "mixed")) {
weighted_mean_overall <- svymean(var_formula, design, na.rm = TRUE)
weighted_var_overall <- svyvar(var_formula, design, na.rm = TRUE)
weighted_stats_strata <- svyby(var_formula, strata_formula, design, svymean, na.rm = TRUE)
weighted_var_strata <- svyby(var_formula, strata_formula, design, svyvar, na.rm = TRUE)
}
row_data <- data.frame(Variable = "", Level = "Mean (SD)", stringsAsFactors = FALSE)
if (mode %in% c("mixed", "weighted")) {
val <- sprintf("%.2f (%.2f)", weighted_mean_overall, sqrt(weighted_var_overall))
} else {
val <- sprintf("%.2f (%.2f)", unweighted_mean_overall, unweighted_sd_overall)
}
row_data$Overall <- val
for (i in seq_along(strata_levels)) {
s_lvl <- strata_levels[i]
if (mode %in% c("mixed", "weighted")) {
mean_val <- weighted_stats_strata[i, var]
sd_val <- sqrt(weighted_var_strata[i, var])
val <- sprintf("%.2f (%.2f)", mean_val, sd_val)
} else {
val <- sprintf("%.2f (%.2f)", unweighted_mean_strata[s_lvl], unweighted_sd_strata[s_lvl])
}
row_data[[s_lvl]] <- val
}
results_list[[length(results_list) + 1]] <- row_data
}
}
final_table <- do.call(rbind, results_list)
return(final_table)
}
# --- 3. Running Example: Flegal (2016) NHANES Data ---
# --- Data Preparation ---
# Load the dataset from a working URL.
load("E:/GitHub/EpiMethods/Data/surveydata/Flegal2016.RData")
# Create the final analytic sample to identify which rows to include (N=5,455)
dat.analytic <- subset(dat.full, RIDAGEYR >= 20 & !is.na(BMXBMI) & (is.na(RIDEXPRG) | RIDEXPRG != 1))
# --- Create Analysis Variables in the Full Dataset ---
dat.full$age <- cut(dat.full$RIDAGEYR, c(20, 40, 60, Inf), right = FALSE, labels = c("20-39", "40-59", "60+"))
dat.full$gender <- factor(dat.full$RIAGENDR, levels = c(1, 2), labels = c("Male", "Female"))
# *** THIS IS THE CORRECTED CODE FOR THE 'race' VARIABLE ***
# The original RIDRETH3 is a factor; we use case_when on its levels.
dat.full <- dat.full %>%
mutate(race = case_when(
RIDRETH3 == "Mexican American" ~ "Hispanic",
RIDRETH3 == "Other Hispanic" ~ "Hispanic",
RIDRETH3 == "Non-Hispanic White" ~ "White",
RIDRETH3 == "Non-Hispanic Black" ~ "Black",
RIDRETH3 == "Non-Hispanic Asian" ~ "Asian",
RIDRETH3 == "Other Race - Including Multi-Racial" ~ "Other",
TRUE ~ NA_character_
))
# Set the desired factor level order for the table output
dat.full$race <- factor(dat.full$race, levels = c("White", "Black", "Asian", "Hispanic", "Other"))
# Create an indicator variable to identify our final analytic sample
dat.full$analytic_sample <- ifelse(dat.full$SEQN %in% dat.analytic$SEQN, 1, 0)
# --- Generate the Weighted Tables using the Correct Workflow ---
# Create ONE main survey design object from the full data
svy.design.full <- svydesign(ids = ~SDMVPSU,
strata = ~SDMVSTRA,
weights = ~WTINT2YR,
data = dat.full,
nest = TRUE)
# Subset the main design to just our analytic sample
svy.design.analytic <- subset(svy.design.full, analytic_sample == 1)
# --- Call svytable1 on the Subsetted Design Objects ---
# These calls will now succeed because the data is correct and the
# function handles lonely PSUs internally.
# -- Part A: Overall Table --
table_overall <- svytable1(design = svy.design.analytic,
strata_var = "race",
table_vars = "age",
mode = "mixed")
#' Perform Reliability Diagnostics on Survey Regression Models
#'
#' @description
#' This function takes a fitted survey regression model object (e.g., from `svyglm`)
#' and produces a tibble with key reliability and diagnostic metrics for each
#' coefficient.
#'
#' @details
#' The output provides a comprehensive overview to help assess the stability and
#' precision of each regression coefficient. The metrics include:
#' \itemize{
#'   \item \strong{Standard Error (SE)}: A measure of the estimate's precision. Smaller is better.
#'   \item \strong{p-value}: The probability of observing the data if the coefficient were zero.
#'   \item \strong{Confidence Interval (CI) Width}: A wide CI indicates greater uncertainty.
#'   \item \strong{Relative Standard Error (RSE)}: Calculated as `(SE / |Estimate|) * 100`.
#' }
#'
#' \strong{Note on RSE}: While included for comparative purposes, the use of RSE to
#' evaluate the reliability of regression coefficients is not recommended by
#' agencies like NCHS/CDC. Coefficients near zero can have an extremely large RSE
#' even if precisely estimated. It is better to rely on the standard error,
#' p-value, and confidence interval width for reliability assessment.
#'
#' @param fit A fitted model object, typically of class `svyglm`.
#' @param p_threshold A numeric value (between 0 and 1) for the significance threshold. Defaults to `0.05`.
#' @param rse_threshold A numeric value for flagging high Relative Standard Error (RSE). Defaults to `30`.
#'
#' @return
#' A `tibble` containing the following columns:
#' \itemize{
#'   \item \code{Term}: The name of the regression coefficient.
#'   \item \code{Estimate}: The coefficient's point estimate (e.g., on the log-odds scale for logistic models).
#'   \item \code{SE}: The standard error of the estimate.
#'   \item \code{p.value}: The p-value for the coefficient.
#'   \item \code{is_significant}: A logical flag, `TRUE` if `p.value` is less than `p_threshold`.
#'   \item \code{CI_Lower}: The lower bound of the 95% confidence interval.
#'   \item \code{CI_Upper}: The upper bound of the 95% confidence interval.
#'   \item \code{CI_Width}: The absolute width of the confidence interval (`CI_Upper - CI_Lower`).
#'   \item \code{RSE_percent}: The Relative Standard Error, as a percentage.
#'   \item \code{is_rse_high}: A logical flag, `TRUE` if `RSE_percent` is greater than or equal to `rse_threshold`.
#' }
#'
#' @importFrom dplyr mutate bind_cols select
#' @importFrom tibble as_tibble
#' @importFrom stats confint setNames
#'
#' @export
#'
#' @examples
#' # Ensure required packages are loaded
#' if (requireNamespace("survey", quietly = TRUE) &&
#'     requireNamespace("NHANES", quietly = TRUE) &&
#'     requireNamespace("dplyr", quietly = TRUE)) {
#'
#'   # 1. Prepare Data using the NHANES example
#'   data(NHANESraw, package = "NHANES")
#'   nhanes_adults_with_na <- NHANESraw %>%
#'     dplyr::filter(Age >= 20) %>%
#'     dplyr::mutate(
#'       ObeseStatus = factor(ifelse(BMI >= 30, "Obese", "Not Obese"),
#'                            levels = c("Not Obese", "Obese")),
#'       Race1 = factor(Race1)
#'     )
#'
#'   # Create a complete-case design object for the regression model
#'   nhanes_complete <- nhanes_adults_with_na[complete.cases(
#'     nhanes_adults_with_na[, c("ObeseStatus", "Age", "Race1")]
#'   ), ]
#'
#'   adult_design_complete <- survey::svydesign(
#'     id = ~SDMVPSU,
#'     strata = ~SDMVSTRA,
#'     weights = ~WTMEC2YR,
#'     nest = TRUE,
#'     data = nhanes_complete
#'   )
#'
#'   # 2. Fit a survey-weighted logistic regression model
#'   fit <- survey::svyglm(
#'     ObeseStatus ~ Age + Race1,
#'     design = adult_design_complete,
#'     family = quasibinomial()
#'   )
#'
#'   # 3. Get the reliability diagnostics table
#'   diagnostics_table <- svyglmdiag(fit)
#'
#'   # Print the resulting table
#'   print(diagnostics_table)
#'
#'   # For a publication-ready table, pipe the result to kable()
#'   if (requireNamespace("knitr", quietly = TRUE)) {
#'     knitr::kable(diagnostics_table,
#'                  caption = "Reliability Diagnostics for NHANES Obesity Model",
#'                  digits = 3)
#'   }
#' }
svyglmdiag <- function(fit, p_threshold = 0.05, rse_threshold = 30) {
# --- Input validation ---
if (!inherits(fit, "svyglm")) {
warning("This function is designed for 'svyglm' objects. Results may be unexpected.")
}
# 1. Get the standard model summary and confidence intervals
summary_fit <- summary(fit)
conf_int_fit <- stats::confint(fit)
# 2. Combine these into a single, informative table
reliability_df <- tibble::as_tibble(summary_fit$coefficients, rownames = "Term")
names(reliability_df) <- c("Term", "Estimate", "SE", "t.value", "p.value")
# 3. Add CIs, calculate metrics, and add flags
reliability_df <- reliability_df %>%
dplyr::bind_cols(tibble::as_tibble(conf_int_fit) %>%
stats::setNames(c("CI_Lower", "CI_Upper"))) %>%
dplyr::mutate(
RSE_percent = (SE / abs(Estimate)) * 100,
CI_Width = CI_Upper - CI_Lower,
is_significant = p.value < p_threshold,
is_rse_high = RSE_percent >= rse_threshold
) %>%
# Reorder and select the final columns for a clean output
dplyr::select(
Term,
Estimate,
SE,
p.value,
is_significant,
CI_Lower,
CI_Upper,
CI_Width,
RSE_percent,
is_rse_high
)
return(reliability_df)
}
library(svyTable1)
library(survey)
library(dplyr)
library(NHANES)
# Load the raw NHANES data (2009-2012)
data(NHANESraw)
# Prepare data for adults, keeping NAs to demonstrate missing data handling
nhanes_adults_with_na <- NHANESraw %>%
filter(Age >= 20) %>%
mutate(
ObeseStatus = factor(ifelse(BMI >= 30, "Obese", "Not Obese"),
levels = c("Not Obese", "Obese"))
)
# Create the survey design object
adult_design_with_na <- svydesign(
id = ~SDMVPSU,
strata = ~SDMVSTRA,
weights = ~WTMEC2YR,
nest = TRUE,
data = nhanes_adults_with_na
)
# Define variables, some with expected missing values
vars_with_missing <- c("Age", "Race1", "Education", "TotChol", "SmokeNow")
# Generate the summary table
table_with_missing <- svytable1(
design = adult_design_with_na,
strata_var = "ObeseStatus",
table_vars = vars_with_missing
)
# Display table
knitr::kable(table_with_missing, caption = "Table 1: Participant Characteristics (with Missing Data)")
library(tidyr)
# Define variables for a complete-case analysis
vars_for_complete_table <- c("Age", "Race1", "BPSysAve", "Pulse", "BMI")
# Create complete-case data
nhanes_adults_complete <- nhanes_adults_with_na %>%
drop_na(all_of(vars_for_complete_table))
# Create a new design object
adult_design_complete <- svydesign(
id = ~SDMVPSU, strata = ~SDMVSTRA, weights = ~WTMEC2YR,
nest = TRUE, data = nhanes_adults_complete
)
# Generate the table
table_without_missing <- svytable1(
design = adult_design_complete,
strata_var = "ObeseStatus",
table_vars = c("Age", "Race1", "BPSysAve", "Pulse")
)
# Display table
knitr::kable(table_without_missing, caption = "Table 2: Participant Characteristics (No Missing Data)")
# Generate the table with reliability checks enabled
results_list <- svytable1(
design = adult_design_with_na,
strata_var = "ObeseStatus",
table_vars = vars_with_missing,
reliability_checks = TRUE,
return_metrics = TRUE
)
# View the formatted table
knitr::kable(results_list$formatted_table)
# View detailed reliability metrics
knitr::kable(results_list$reliability_metrics)
fit_obesity <- svyglm(
ObeseStatus ~ Age + Gender + Race1,
design = adult_design_complete,
family = quasibinomial()
)
# 2. Get the reliability diagnostics table for the model
diagnostics_table <- svyglmdiag(fit_obesity)
# 3. Display the diagnostics table
knitr::kable(
diagnostics_table,
caption = "Table 3: Reliability Diagnostics for Obesity Model Coefficients",
digits = 3
)
devtools::document()
devtools::check()
devtools::check()
devtools::check()
# Run a check without building vignettes
devtools::check(build_vignettes = FALSE)
devtools::document()
# Run a check without building vignettes
devtools::check(build_vignettes = FALSE)
devtools::check(args = "--no-build-vignettes")
devtools::document()
devtools::check(args = "--no-build-vignettes")
devtools::build_vignettes()
devtools::check()
# This will automatically change 0.2.0 to 0.3.0
usethis::use_version("minor")
