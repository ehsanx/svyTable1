addintlist <- function(model,
factor1_name,
factor2_name,
measures = "all",
conf.level = 0.95) {
# Check if the core calculation function 'addint' exists
if (!exists("addint") || !is.function(addint)) {
stop("The 'addint' function is required but was not found. Ensure it is loaded.", call. = FALSE)
}
if (!inherits(model, c("svycoxph", "svyglm", "coxph", "glm"))) {
warning("Model object may not be of a supported type.")
# Attempt to proceed anyway
}
beta <- tryCatch(stats::coef(model), error = function(e) NULL)
if (is.null(beta)) {
warning("Could not extract coefficients from the model.")
return(NULL)
}
coef_names_all <- names(beta)
# --- Get Factor Levels (excluding reference) ---
levels1 <- NULL
levels2 <- NULL
# Try accessing xlevels if they exist (common in lm, glm)
if (!is.null(model$xlevels)) {
levels1 <- model$xlevels[[factor1_name]]
levels2 <- model$xlevels[[factor2_name]]
} else if (inherits(model, "survey.design")) {
# For survey design objects passed directly (less common)
if (factor1_name %in% names(model$variables) && is.factor(model$variables[[factor1_name]])) {
levels1 <- levels(model$variables[[factor1_name]])
}
if (factor2_name %in% names(model$variables) && is.factor(model$variables[[factor2_name]])) {
levels2 <- levels(model$variables[[factor2_name]])
}
} else if (!is.null(model$survey.design)) {
# For survey model objects (svyglm, svycoxph)
model_data_vars <- model$survey.design$variables
if (factor1_name %in% names(model_data_vars) && is.factor(model_data_vars[[factor1_name]])) {
levels1 <- levels(model_data_vars[[factor1_name]])
}
if (factor2_name %in% names(model_data_vars) && is.factor(model_data_vars[[factor2_name]])) {
levels2 <- levels(model_data_vars[[factor2_name]])
}
} else if (!is.null(model$data)) {
# For some other model types that might store data
if (factor1_name %in% names(model$data) && is.factor(model$data[[factor1_name]])) {
levels1 <- levels(model$data[[factor1_name]])
}
if (factor2_name %in% names(model$data) && is.factor(model$data[[factor2_name]])) {
levels2 <- levels(model$data[[factor2_name]])
}
}
if (is.null(levels1) || length(levels1) < 2) {
warning("Could not automatically determine levels for factor1: ", factor1_name, ". Check if it's a factor with >1 level in the model data.")
return(NULL)
}
if (is.null(levels2) || length(levels2) < 2) {
warning("Could not automatically determine levels for factor2: ", factor2_name, ". Check if it's a factor with >1 level in the model data.")
return(NULL)
}
ref_level1 <- levels1[1]
ref_level2 <- levels2[1]
non_ref_levels1 <- levels1[-1]
non_ref_levels2 <- levels2[-1]
all_results <- list()
# --- Loop through combinations of non-reference levels ---
for (level1 in non_ref_levels1) {
for (level2 in non_ref_levels2) {
comparison_name <- paste0(factor1_name, "_", level1, "_vs_", factor2_name, "_", level2)
message("Calculating for: ", comparison_name)
# --- Construct coefficient names ---
exp1_coef_name <- paste0(factor1_name, level1)
exp2_coef_name <- paste0(factor2_name, level2)
inter_coef_name1 <- paste0(factor1_name, level1, ":", factor2_name, level2)
inter_coef_name2 <- paste0(factor2_name, level2, ":", factor1_name, level1)
inter_coef_name <- NULL
if (inter_coef_name1 %in% coef_names_all) {
inter_coef_name <- inter_coef_name1
} else if (inter_coef_name2 %in% coef_names_all) {
inter_coef_name <- inter_coef_name2
}
# Check if all needed coefficients were found
current_coef_names_list <- list(
exp1_coef = exp1_coef_name,
exp2_coef = exp2_coef_name,
inter_coef = inter_coef_name
)
required_in_model <- c(exp1_coef_name, exp2_coef_name, inter_coef_name)
if (is.null(inter_coef_name) || any(!required_in_model %in% coef_names_all) ) {
warning("Could not find all necessary coefficients for interaction between ",
level1, " and ", level2, ". Skipping this combination.")
all_results[[comparison_name]] <- list(error = "Coefficients not found")
next # Skip to the next combination
}
# --- Call the calculation function 'addint' ---
interaction_results <- addint( # Call the dependency function
model = model,
type = "interaction",
coef_names = current_coef_names_list,
measures = measures,
conf.level = conf.level
)
all_results[[comparison_name]] <- interaction_results
}
}
return(all_results)
}
# Ensure the 'addint' function is defined or loaded from the package
# source("R/addint.R") # If running interactively before package build
#'
if (requireNamespace("survey", quietly = TRUE) &&
requireNamespace("NHANES", quietly = TRUE) &&
requireNamespace("dplyr", quietly = TRUE) &&
requireNamespace("tidyr", quietly = TRUE) &&
requireNamespace("msm", quietly = TRUE)) {
#'
library(survey)
library(NHANES)
library(dplyr)
library(tidyr)
library(msm)
#'
# --- 1. Data Preparation (NHANES Example) ---
data(NHANESraw)
#'
vars_needed <- c("Age", "Race1", "BPSysAve", "BMI", "ObeseStatus", "Hypertension_130",
"SDMVPSU", "SDMVSTRA", "WTMEC2YR")
#'
nhanes_adults_processed <- NHANESraw %>%
filter(Age >= 20) %>%
mutate(
ObeseStatus = factor(ifelse(BMI >= 30, "Obese", "Not Obese"),
levels = c("Not Obese", "Obese")),
Hypertension_130 = factor(ifelse(BPSysAve >= 130, "Yes", "No"),
levels = c("No", "Yes")),
Race1 = relevel(as.factor(Race1), ref = "White")
) %>%
select(all_of(vars_needed)) %>%
drop_na()
#'
adult_design_binary <- svydesign(
id = ~SDMVPSU, strata = ~SDMVSTRA, weights = ~WTMEC2YR,
nest = TRUE, data = nhanes_adults_processed
)
#'
# --- 2. Fit Interaction Term Model ---
interaction_model_logit <- svyglm(
Hypertension_130 ~ Race1 * ObeseStatus + Age,
design = adult_design_binary, family = quasibinomial()
)
#'
# --- 3. Calculate all additive interactions ---
all_interactions_list <- addintlist(
model = interaction_model_logit,
factor1_name = "Race1",
factor2_name = "ObeseStatus",
measures = "all"
)
#'
# Print the results list
print(all_interactions_list)
#'
# Example: Extract RERI for a specific interaction
# print(all_interactions_list$Race1_Black_vs_ObeseStatus_Obese$RERI)
#'
} else {
print("Required packages (survey, NHANES, dplyr, tidyr, msm) not found.")
}
}
#' Calculate All Additive Interaction Measures from an Interaction Model
#'
#' @description
#' Automatically identifies interaction terms in a fitted model involving two
#' categorical factors (e.g., `~ A * B`) and calculates measures of additive
#' interaction (RERI, AP, S) for each combination of non-reference levels.
#' This function requires the `addint()` function to be available.
#'
#' @details
#' This function serves as a wrapper around `addint()`. It determines the
#' levels of the two specified factors from the model object, constructs the
#' expected coefficient names for main effects and interaction terms (checking
#' both `A:B` and `B:A` formats), and then calls `addint()` with
#' `type = "interaction"` for each valid combination found in the model.
#' The results are compiled into a single summary table.
#'
#' @param model A fitted model object (e.g., `svycoxph`, `svyglm`) of type
#'   `"interaction"` (containing a `factor1 * factor2` term).
#' @param factor1_name Character string: The name of the first factor variable
#'   in the interaction (e.g., `"Race1"`).
#' @param factor2_name Character string: The name of the second factor variable
#'   (e.g., `"ObeseStatus"`).
#' @param measures A character vector specifying which measures to calculate via `addint()`.
#'   Options: `"RERI"`, `"AP"`, `"S"`, or `"all"`. Default is `"all"`.
#' @param conf.level Confidence level for the interval (default 0.95).
#' @param digits Integer. Number of decimal places for rounding estimates and
#'   CIs in the final table. Default is 3. (Set to NULL for no rounding).
#'
#' @return A `tibble` (data frame) summarizing the additive interaction results.
#'   Columns include:
#'   \itemize{
#'     \item `Factor1`: Name of the first factor.
#'     \item `Level1`: Non-reference level of the first factor for the comparison.
#'     \item `Factor2`: Name of the second factor.
#'     \item `Level2`: Non-reference level of the second factor for the comparison.
#'     \item `Measure`: The additive interaction measure calculated ("RERI", "AP", or "S").
#'     \item `Estimate`: Point estimate of the measure.
#'     \item `SE`: Standard Error (Note: For S, this is SE of log(S)).
#'     \item `CI_low`: Lower confidence interval bound.
#'     \item `CI_upp`: Upper confidence interval bound.
#'   }
#'   Returns an empty tibble if errors occur.
#'
#' @seealso \code{\link{addint}}
#'
#' @importFrom stats coef
#' @importFrom tibble tibble
#' @importFrom dplyr bind_rows mutate relocate select
#' @importFrom tidyr pivot_longer
#' @importFrom rlang :=
#'
#' @export
#'
#' @examples
#' \donttest{
#' # --- Load required libraries for the example ---
#' # Ensure the 'addint' function is defined or loaded from the package
#' # source("R/addint.R") # If running interactively before package build
#'
#' if (requireNamespace("survey", quietly = TRUE) &&
#'     requireNamespace("NHANES", quietly = TRUE) &&
#'     requireNamespace("dplyr", quietly = TRUE) &&
#'     requireNamespace("tidyr", quietly = TRUE) &&
#'     requireNamespace("msm", quietly = TRUE)) {
#'
#'   library(survey)
#'   library(NHANES)
#'   library(dplyr)
#'   library(tidyr)
#'   library(msm)
#'
#'   # --- 1. Data Preparation (NHANES Example) ---
#'   data(NHANESraw)
#'
#'   vars_needed <- c("Age", "Race1", "BPSysAve", "BMI", "ObeseStatus", "Hypertension_130",
#'                    "SDMVPSU", "SDMVSTRA", "WTMEC2YR")
#'
#'   nhanes_adults_processed <- NHANESraw %>%
#'     filter(Age >= 20) %>%
#'     mutate(
#'       ObeseStatus = factor(ifelse(BMI >= 30, "Obese", "Not Obese"),
#'                            levels = c("Not Obese", "Obese")),
#'       Hypertension_130 = factor(ifelse(BPSysAve >= 130, "Yes", "No"),
#'                                 levels = c("No", "Yes")),
#'       Race1 = relevel(as.factor(Race1), ref = "White")
#'     ) %>%
#'     select(all_of(vars_needed)) %>%
#'     drop_na()
#'
#'   adult_design_binary <- svydesign(
#'     id = ~SDMVPSU, strata = ~SDMVSTRA, weights = ~WTMEC2YR,
#'     nest = TRUE, data = nhanes_adults_processed
#'   )
#'
#'   # --- 2. Fit Interaction Term Model ---
#'   interaction_model_logit <- svyglm(
#'     Hypertension_130 ~ Race1 * ObeseStatus + Age,
#'     design = adult_design_binary, family = quasibinomial()
#'   )
#'
#'   # --- 3. Calculate all additive interactions ---
#'   all_interactions_table <- addintlist(
#'     model = interaction_model_logit,
#'     factor1_name = "Race1",
#'     factor2_name = "ObeseStatus",
#'     measures = "all"
#'   )
#'
#'   # Print the results table
#'   print(all_interactions_table, n=50)
#'
#' } else {
#'   print("Required packages (survey, NHANES, dplyr, tidyr, msm) not found.")
#' }
#' }
addintlist <- function(model,
factor1_name,
factor2_name,
measures = "all",
conf.level = 0.95,
digits = 3) { # Added digits argument
# Check if the core calculation function 'addint' exists
if (!exists("addint") || !is.function(addint)) {
stop("The 'addint' function is required but was not found. Ensure it is loaded.", call. = FALSE)
}
valid_measures_req <- c("RERI", "AP", "S", "all")
if (any(!measures %in% valid_measures_req)) {
stop("Invalid measure specified in 'measures'. Choose from 'RERI', 'AP', 'S', or 'all'.", call. = FALSE)
}
if ("all" %in% measures) {
measures_to_calc <- c("RERI", "AP", "S")
} else {
measures_to_calc <- unique(measures)
}
if (!inherits(model, c("svycoxph", "svyglm", "coxph", "glm"))) {
warning("Model object may not be of a supported type.")
# Attempt to proceed anyway
}
beta <- tryCatch(stats::coef(model), error = function(e) NULL)
if (is.null(beta)) {
warning("Could not extract coefficients from the model.")
return(tibble::tibble()) # Return empty tibble
}
coef_names_all <- names(beta)
# --- Get Factor Levels (excluding reference) ---
levels1 <- NULL
levels2 <- NULL
# Try accessing xlevels if they exist (common in lm, glm)
if (!is.null(model$xlevels)) {
levels1 <- model$xlevels[[factor1_name]]
levels2 <- model$xlevels[[factor2_name]]
} else if (inherits(model, "survey.design")) {
# For survey design objects passed directly (less common)
if (factor1_name %in% names(model$variables) && is.factor(model$variables[[factor1_name]])) {
levels1 <- levels(model$variables[[factor1_name]])
}
if (factor2_name %in% names(model$variables) && is.factor(model$variables[[factor2_name]])) {
levels2 <- levels(model$variables[[factor2_name]])
}
} else if (!is.null(model$survey.design)) {
# For survey model objects (svyglm, svycoxph)
model_data_vars <- model$survey.design$variables
if (factor1_name %in% names(model_data_vars) && is.factor(model_data_vars[[factor1_name]])) {
levels1 <- levels(model_data_vars[[factor1_name]])
}
if (factor2_name %in% names(model_data_vars) && is.factor(model_data_vars[[factor2_name]])) {
levels2 <- levels(model_data_vars[[factor2_name]])
}
} else if (!is.null(model$data)) {
# For some other model types that might store data
if (factor1_name %in% names(model$data) && is.factor(model$data[[factor1_name]])) {
levels1 <- levels(model$data[[factor1_name]])
}
if (factor2_name %in% names(model$data) && is.factor(model$data[[factor2_name]])) {
levels2 <- levels(model$data[[factor2_name]])
}
}
if (is.null(levels1) || length(levels1) < 2) {
warning("Could not automatically determine levels for factor1: ", factor1_name, ". Check if it's a factor with >1 level in the model data.")
return(tibble::tibble()) # Return empty tibble
}
if (is.null(levels2) || length(levels2) < 2) {
warning("Could not automatically determine levels for factor2: ", factor2_name, ". Check if it's a factor with >1 level in the model data.")
return(tibble::tibble()) # Return empty tibble
}
ref_level1 <- levels1[1]
ref_level2 <- levels2[1]
non_ref_levels1 <- levels1[-1]
non_ref_levels2 <- levels2[-1]
all_results_list <- list() # Store results before binding
# --- Loop through combinations of non-reference levels ---
for (level1 in non_ref_levels1) {
for (level2 in non_ref_levels2) {
comparison_name <- paste0(factor1_name, "_", level1, "_vs_", factor2_name, "_", level2)
message("Calculating for: ", comparison_name)
# --- Construct coefficient names ---
exp1_coef_name <- paste0(factor1_name, level1)
exp2_coef_name <- paste0(factor2_name, level2)
inter_coef_name1 <- paste0(factor1_name, level1, ":", factor2_name, level2)
inter_coef_name2 <- paste0(factor2_name, level2, ":", factor1_name, level1)
inter_coef_name <- NULL
if (inter_coef_name1 %in% coef_names_all) {
inter_coef_name <- inter_coef_name1
} else if (inter_coef_name2 %in% coef_names_all) {
inter_coef_name <- inter_coef_name2
}
# Check if all needed coefficients were found
current_coef_names_list <- list(
exp1_coef = exp1_coef_name,
exp2_coef = exp2_coef_name,
inter_coef = inter_coef_name
)
required_in_model <- c(exp1_coef_name, exp2_coef_name, inter_coef_name)
if (is.null(inter_coef_name) || any(!required_in_model %in% coef_names_all) ) {
warning("Could not find all necessary coefficients for interaction between ",
level1, " and ", level2, ". Skipping this combination.")
# Store minimal info about the skip
all_results_list[[length(all_results_list) + 1]] <- tibble::tibble(
Factor1 = factor1_name, Level1 = level1,
Factor2 = factor2_name, Level2 = level2,
Measure = "Error", Estimate = NA_real_, SE = NA_real_,
CI_low = NA_real_, CI_upp = NA_real_
)
next # Skip to the next combination
}
# --- Call the calculation function 'addint' ---
interaction_results <- addint( # Call the dependency function
model = model,
type = "interaction",
coef_names = current_coef_names_list,
measures = measures_to_calc, # Use the validated list
conf.level = conf.level
)
# --- Process results into a flat tibble for this combination ---
if (!is.null(interaction_results) && length(interaction_results) > 0) {
for(measure_name in names(interaction_results)) {
res_vector <- interaction_results[[measure_name]]
se_val <- ifelse(measure_name == "S", res_vector["S_SE_log"], res_vector[2]) # Get correct SE column
all_results_list[[length(all_results_list) + 1]] <- tibble::tibble(
Factor1 = factor1_name,
Level1 = level1,
Factor2 = factor2_name,
Level2 = level2,
Measure = measure_name,
Estimate = res_vector[1], # First element is always estimate
SE = se_val,
CI_low = res_vector[3], # Third element is always LowerCI
CI_upp = res_vector[4]  # Fourth element is always UpperCI
)
}
} else {
# Store minimal info if addint returned NULL
all_results_list[[length(all_results_list) + 1]] <- tibble::tibble(
Factor1 = factor1_name, Level1 = level1,
Factor2 = factor2_name, Level2 = level2,
Measure = "Error", Estimate = NA_real_, SE = NA_real_,
CI_low = NA_real_, CI_upp = NA_real_
)
warning("Calculation failed within addint() for interaction between ",
level1, " and ", level2, ". Check previous warnings.")
}
} # end loop level2
} # end loop level1
# --- Combine all results into a single tibble ---
if (length(all_results_list) == 0) {
warning("No interaction results could be calculated.")
# Return an empty tibble with correct columns
return(tibble::tibble(Factor1 = character(), Level1 = character(),
Factor2 = character(), Level2 = character(),
Measure = character(), Estimate = double(), SE = double(),
CI_low = double(), CI_upp = double()))
}
final_table <- dplyr::bind_rows(all_results_list)
# --- Optional rounding ---
if (!is.null(digits)) {
final_table <- final_table %>%
dplyr::mutate(dplyr::across(c(Estimate, SE, CI_low, CI_upp), ~round(.x, digits)))
}
# --- Final structure ---
final_table <- final_table %>%
dplyr::relocate(Factor1, Level1, Factor2, Level2, Measure, Estimate, SE, CI_low, CI_upp)
return(final_table)
}
# --- Load required libraries for the example ---
# Ensure the 'addint' function is defined or loaded from the package
# source("R/addint.R") # If running interactively before package build
#'
if (requireNamespace("survey", quietly = TRUE) &&
requireNamespace("NHANES", quietly = TRUE) &&
requireNamespace("dplyr", quietly = TRUE) &&
requireNamespace("tidyr", quietly = TRUE) &&
requireNamespace("msm", quietly = TRUE)) {
#'
library(survey)
library(NHANES)
library(dplyr)
library(tidyr)
library(msm)
#'
# --- 1. Data Preparation (NHANES Example) ---
data(NHANESraw)
#'
vars_needed <- c("Age", "Race1", "BPSysAve", "BMI", "ObeseStatus", "Hypertension_130",
"SDMVPSU", "SDMVSTRA", "WTMEC2YR")
#'
nhanes_adults_processed <- NHANESraw %>%
filter(Age >= 20) %>%
mutate(
ObeseStatus = factor(ifelse(BMI >= 30, "Obese", "Not Obese"),
levels = c("Not Obese", "Obese")),
Hypertension_130 = factor(ifelse(BPSysAve >= 130, "Yes", "No"),
levels = c("No", "Yes")),
Race1 = relevel(as.factor(Race1), ref = "White")
) %>%
select(all_of(vars_needed)) %>%
drop_na()
#'
adult_design_binary <- svydesign(
id = ~SDMVPSU, strata = ~SDMVSTRA, weights = ~WTMEC2YR,
nest = TRUE, data = nhanes_adults_processed
)
#'
# --- 2. Fit Interaction Term Model ---
interaction_model_logit <- svyglm(
Hypertension_130 ~ Race1 * ObeseStatus + Age,
design = adult_design_binary, family = quasibinomial()
)
#'
# --- 3. Calculate all additive interactions ---
all_interactions_table <- addintlist(
model = interaction_model_logit,
factor1_name = "Race1",
factor2_name = "ObeseStatus",
measures = "all"
)
#'
# Print the results table
print(all_interactions_table, n=50)
#'
} else {
print("Required packages (survey, NHANES, dplyr, tidyr, msm) not found.")
}
}
